## 华为软件杯设计思路

### 第一版 

```c++
‘.’ ： 空地
‘*’ ： 海洋
‘#’ ： 障碍
‘A’ ： 机器人起始位置，总共10个。
‘B’ ： 大小为4*4，表示泊位的位置,泊位标号在后泊位处初始化。
```



#### 货物：双向链表

- 变量：
  - 货物价值
  - 货物位置 x,y
  - 货物消失时的帧id
  - next指针，font指针
- 函数：
  - add
    -  添加一个货物到链表，计算每个空机器人和它的距离，如果比空机器人原来的目标货物更近，或者最少的步数加上当前帧时间，大于等于目标货物的生命周期，则更新目标货物为当前货物

假设：所有货物都是等值的



#### 机器人：

- 新增变量：

  - 历史状态记录 （五元组） 上2下3左1右0，上一个状态方向0~3
  - 操作状态记录    01 是否在当前帧操作过
  - 货物目标指针
  - 伯口id

  

- 函数

  - run   可选参数 ： tar 指定某一个意向前进方向

    - 更新每个机器人，在历史状态和目标的约束下，让他走一步，并更新其历史状态
    - 当走一步之后，若到达目标，执行拿/放下货物的操作，如果拿起货物，则计算最近的伯口并更新目标，再把该货物从货物链表中移出，如果放下货物，则释放该货物的空间，如果放不下货物，则（先暂时不考虑）

  - pre_run

    - 返回可选意向的前进方向

    

思考

1. 走步函数
2. 设计一个历史的机器人方向状态数量和上一步的记录（五元组，只记录，与原方向相反的冲突的方向的数量），保证如果存在路径可以绕过障碍，不存在环绕的情况。
3. 给每个机器人设置一个状态，0表示还未考虑，1表示考虑了这个状态，所有的机器人每一帧都要走一步
4. 对于拿到货的机器人，计算最近的泊口，并设置该泊口为目标

5. 解决碰撞：

​	**当有货的机器人，前进的路上有检测到其他机器人**

​	情况一：前进方向上有个机器人挡路

1. 该机器人有货，大概率是同一个伯口，保险起见，更新其为自己的目标伯口，计算自己的意向步骤，然后根据方向同时更新两个机器人
2. 该机器人无货，设置其历史状态中的上一个状态方向为朝向该机器人的方向（这样，更新该机器人步数的时候，就不会往那边撞了）

​	

​	**当无货的机器人，在前进的路上检测到其他机器人**

​	情况一：前进方向上有个机器人挡路

1. 该机器人有货，优先更新有货机器人的方向 ，再更新自己的
2. 该机器人无货，先计算两者的意向方向，如果可以找到不冲突的方向最好，但他们大概率是在争抢同一个货物，所以是同一个方向，冲突的话，直接交换两个机器人的目标货物。

​	





#### **伯口**：

- 变量
  - vector\<int\> 当前伯口，累积的货物数量 
  - vector\<int\> 当前伯口是否有船只正在往这边驶来，或已经停靠在此
- 函数
  - update 每次更新伯口，如果有船就清除一定累积的数量，船的货物满了即刻出发，如果没有船，就按顺序紧凑排放货物，如果积累的货物超过了一半，那就检查所有的船只，让-1的船往伯口出发，没有-1的船，就选择当前船只。

#### **机器人步骤**

- 变量 vector\<string\>  记录每个机器人要执行的操作

#### **船步骤**

- 变量 

  - vector\<string\>  记录每个船要执行的操作 

    

- 函数：

  - 初始化：选两个耗时最长的伯口，2条船先出发

    